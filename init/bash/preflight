#!/bin/sh
#
#  <preflight>
#    Copyright 2008 James Cook - All Rights Reserved.
#
#

#
# find out where we live, assuming a sensible default
#
export deepbondi=${deepbondi:-/deepbondi}

#
# Locate user scripts, if any
#
bash_initdir=${bash_initdir:-${deepbondi}/init/bash}

if [ -d ~/Library/init/bash ]; then
	# nicer place, for mac users - easier to remember to back up
	# (or to back up without specifically remembering)
	user_bash_initdir=${user_bash_initdir:-~/Library/init/bash}
fi

# if still not set, use default
user_bash_initdir=${user_bash_initdir:-~/.init/bash}

#
# set up some useful environment variables that are 
# hard to get right in a portable way (and that we will want often)
#
# do it in a function so we can use a local $PATH (is there another
# way to use local here that will allow environment vars to escape?)
#
function __preflight_getOS {
	local PATH=/bin:/sbin:/usr/bin:/usr/sbin
	
	uname -o >/dev/null 2>&1
	if [ $? == 0 ]; then
		export os=`uname -o`
		
		if echo $os | grep -q '/' ; then
			export os=`uname`
		fi
	else
		export os=`uname`
	fi
	
	arch=`uname -m`
	if echo $arch | grep -q ' ' ; then
		arch=`uname -p`
	fi
	export arch
}
__preflight_getOS
unset __preflight_getOS

# create a "which"-like function, because 'which -s' isn't available
# everywhere, and the redirects are annoying
if which _this_name_better_not_exist_ > /dev/null 2>&1; then
	# which is not reliable; use alternate means
	if which _this_name_better_not_exist_ 2> /dev/null | grep -qv '^/'; then
		function cmdExists {
			which "$@" 2> /dev/null | grep -q '^/'
		}
	else
		echo Warning: don\'t know how to make a reliable \"cmdExists\"
		echo function on this system.  Making a dummy that always fails.

		function cmdExists {
			false
		}
	fi
else
	# which is ok, use it
	function cmdExists {
		which "$@" > /dev/null 2>&1
	}
fi
