#!/usr/bin/perl
#
#  <wrap>
#    Copyright 2010 James Cook - All Rights Reserved.
#
#

use strict;
use Getopt::Std;

our %opts;
our $delim = qr/\s+/;

our $outWidth = 72;
our $col = 0;
our @wordBuf;

exit main();

sub HELP_MESSAGE {
    usage(0);
}
sub usage {
    my ($exitWith, $msg) = @_;
    
    if (defined $msg) {
        print STDERR $msg;
        print STDERR "\n";
    }

    print STDERR <<EOF;

    Usage:  wrap
    
    Options:
        -h          show this help message
        -w<width>   specify width to wrap input at (default = 72)
        -d<delims>  specify delimiter regex for wrapping (default = "\s+")

EOF
    exit $exitWith if defined($exitWith);
}

sub wrap {
    my @lines = @_;
    
    my @words;
    for my $line (@lines) {
        my @lineWords = split $delim, $line;
        push @words, @lineWords;
    }
    
    @lines = ();
    for my $word (@words) {
        my $wLen = length $word;
        if ($wLen + $col >= $outWidth) {
            my $outLine = join ' ', @wordBuf;
            @wordBuf = ();
            
            push @lines, $outLine;
            $col = 0;
        } else {
            $col++;
        }
        
        push @wordBuf, $word;
        $col += $wLen;
    }
    
    return \@lines;
}

sub main {
    getopts("w:d:", \%opts) or usage(-1);
    usage(0)    if ($opts{'h'});
    usage(-1)   if (@ARGV > 0);
    
    $delim = qr/${opts{'d'}}/   if defined $opts{'d'};
    $outWidth = $opts{'w'}      if defined $opts{'w'};
    
    while(<STDIN>) {
        my @wrapped = @{ wrap($_) };
        map { print "$_\n" } @wrapped;
    }
    
    print (join " ", @wordBuf);
    print "\n";
    return 0;
}